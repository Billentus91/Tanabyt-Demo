# -*- coding: utf-8 -*-
"""Streamlit Volatility Forecasting App 2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hGvyxX0yr0ImFzOuNQrir8DJo_Ccba57
"""

import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
from arch import arch_model
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
import matplotlib.pyplot as plt
import plotly.graph_objects as go

# --- Streamlit App Configuration ---
st.set_page_config(
    page_title="ETF Volatility Forecasting",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- Data Caching Functions ---
@st.cache_data
def load_data(ticker, start_date='2010-01-01'):
    """Fetches and caches historical stock data from Yahoo Finance."""
    data = yf.download(ticker, start=start_date)
    return data

# --- GARCH Model Function ---
@st.cache_resource
def run_garch_model(returns):
    """
    Fits and forecasts with a GARCH(1,1) model.
    Returns the fitted volatility series and the 1-step forecast.
    """
    try:
        # Fit a GARCH(1,1) model on the returns
        am = arch_model(returns, vol='Garch', p=1, q=1, dist='StudentsT')
        res = am.fit(disp='off')

        # Get the conditional volatility series from the fitted model
        garch_volatility = res.conditional_volatility

        # Make a forecast for the next period
        forecasts = res.forecast(horizon=1)
        # Extract the variance and square root it for volatility
        garch_forecast = np.sqrt(forecasts.variance.values[-1, :][0])

        return garch_volatility, garch_forecast

    except Exception as e:
        st.error(f"GARCH model fitting failed: {e}")
        return None, None

# --- LSTM Model Training Function ---
@st.cache_resource
def train_lstm_model(data, n_steps=30):
    """
    Trains a simple LSTM model for volatility forecasting.
    This function uses a cached resource to prevent re-training on every interaction.
    """
    st.info("Training LSTM model... This may take a moment.")

    # Feature Engineering: Use GARCH volatility as a key feature for the LSTM
    # We must run the GARCH model first to get this feature
    garch_volatility, _ = run_garch_model(data['Returns'])

    # Prepare the DataFrame for LSTM
    df_lstm = pd.DataFrame(garch_volatility, columns=['GARCH_Volatility'])

    # --- FIX: Drop NaN values before scaling to prevent errors ---
    df_lstm.dropna(inplace=True)

    # Scale the data for the LSTM model
    scaler = MinMaxScaler(feature_range=(0, 1))
    scaled_data = scaler.fit_transform(df_lstm[['GARCH_Volatility']])

    # Create the LSTM dataset
    X, y = [], []
    for i in range(n_steps, len(scaled_data)):
        X.append(scaled_data[i-n_steps:i, 0])
        y.append(scaled_data[i, 0])

    # Ensure there is enough data for the LSTM to train
    if not X:
        st.error("Not enough data to train the LSTM model. Please check the dataset and n_steps.")
        return None, None, None, None, None, None, None

    X, y = np.array(X), np.array(y)
    X = np.reshape(X, (X.shape[0], X.shape[1], 1))

    # Build the LSTM model
    model = Sequential([
        LSTM(50, activation='relu', input_shape=(n_steps, 1)),
        Dropout(0.2),
        Dense(1)
    ])
    model.compile(optimizer='adam', loss='mean_squared_error')

    # Train the model
    model.fit(X, y, epochs=50, batch_size=32, verbose=0)

    # Evaluate the model on the training data
    y_pred_scaled = model.predict(X, verbose=0)
    y_pred_unscaled = scaler.inverse_transform(y_pred_scaled)
    y_actual_unscaled = scaler.inverse_transform(y.reshape(-1, 1))

    mse = mean_squared_error(y_actual_unscaled, y_pred_unscaled)
    rmse = np.sqrt(mse)

    st.success("LSTM model training complete!")
    return model, scaler, X, y_actual_unscaled, y_pred_unscaled, mse, rmse

# --- Main Streamlit Application ---
def main():
    st.title("ETF Volatility Forecasting App")
    st.markdown("Forecast and compare rolling volatility for SPY and QQQ using GARCH and LSTM models.")

    # --- Sidebar for User Inputs ---
    st.sidebar.header("User Selections")
    ticker = st.sidebar.selectbox("Choose an ETF:", ['SPY', 'QQQ'])
    forecast_days = st.sidebar.slider("Forecast Period (Days)", min_value=5, max_value=10, step=5)
    selected_model = st.sidebar.selectbox("Select Model for Detailed View:", ['GARCH', 'LSTM'])

    # --- Data Loading and Preparation ---
    with st.spinner(f"Fetching data for {ticker}..."):
        try:
            df = load_data(ticker)
            df['Returns'] = df['Close'].pct_change().dropna()
            df['Rolling_Volatility'] = df['Returns'].rolling(window=forecast_days).std() * np.sqrt(252) # Annualized

            # --- FIX: Drop any remaining NaNs after calculations ---
            df.dropna(inplace=True)

        except Exception as e:
            st.error(f"Failed to load data for {ticker}. Please try again later. Error: {e}")
            return

    # --- Model Training and Forecasting ---
    with st.spinner("Running GARCH and LSTM models..."):
        garch_volatility_series, garch_forecast_value = run_garch_model(df['Returns'])

        # Check if GARCH model failed
        if garch_volatility_series is None:
            st.error("GARCH model failed to run. Cannot proceed with LSTM model training.")
            return

        lstm_model, scaler, X, y_actual, y_pred, lstm_mse, lstm_rmse = train_lstm_model(df, n_steps=30)

        # Check if LSTM model failed
        if lstm_model is None:
            st.error("LSTM model failed to train. Cannot proceed with forecasting.")
            return

    # LSTM Prediction for next period
    last_data_scaled = scaler.transform(np.array(garch_volatility_series.tail(30)).reshape(-1, 1))
    last_data_reshaped = np.reshape(last_data_scaled, (1, 30, 1))
    lstm_forecast_scaled = lstm_model.predict(last_data_reshaped, verbose=0)
    lstm_forecast_value = scaler.inverse_transform(lstm_forecast_scaled)[0][0]

    st.header("Forecast Results")
    col1, col2 = st.columns(2)
    with col1:
        st.metric(label=f"GARCH {forecast_days}-Day Volatility Forecast", value=f"{garch_forecast_value:.4f}")
    with col2:
        st.metric(label=f"LSTM {forecast_days}-Day Volatility Forecast", value=f"{lstm_forecast_value:.4f}")

    # --- Visualization: GARCH vs LSTM Forecasts ---
    st.subheader(f"Volatility Forecast Comparison for {ticker}")

    # Create the base graph
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=garch_volatility_series.index, y=garch_volatility_series, mode='lines', name='GARCH Volatility', line=dict(color='green')))

    # Add LSTM predictions (which are a result of the training data)
    df_lstm_predictions = pd.DataFrame(y_pred, index=garch_volatility_series.index[30:], columns=['LSTM Volatility'])
    fig.add_trace(go.Scatter(x=df_lstm_predictions.index, y=df_lstm_predictions['LSTM Volatility'], mode='lines', name='LSTM Volatility', line=dict(color='orange')))

    # Add a marker for the latest forecast
    latest_date = df.index[-1]
    forecast_date = latest_date + pd.Timedelta(days=forecast_days)
    fig.add_trace(go.Scatter(x=[latest_date, forecast_date], y=[garch_volatility_series.iloc[-1], garch_forecast_value],
                             mode='markers+lines', name='GARCH Forecast', line=dict(dash='dash'), marker=dict(color='green', size=8)))
    fig.add_trace(go.Scatter(x=[latest_date, forecast_date], y=[df_lstm_predictions.iloc[-1]['LSTM Volatility'], lstm_forecast_value],
                             mode='markers+lines', name='LSTM Forecast', line=dict(dash='dash'), marker=dict(color='orange', size=8)))

    fig.update_layout(
        title=f'{ticker} Volatility Forecast',
        xaxis_title='Date',
        yaxis_title='Annualized Volatility',
        hovermode='x unified',
        template='plotly_dark'
    )
    st.plotly_chart(fig, use_container_width=True)

    # --- Model-Specific View (Dropdown Selection) ---
    st.header(f"Detailed View: {selected_model} Model")

    if selected_model == 'GARCH':
        st.write("The GARCH model is a statistical model used to estimate the volatility of a financial time series.")

        # Plot GARCH Volatility vs. Historical Volatility
        fig_garch, ax_garch = plt.subplots(figsize=(10, 5))
        ax_garch.plot(df.index, garch_volatility_series, label='GARCH Volatility', color='green')
        ax_garch.plot(df.index, df['Rolling_Volatility'], label=f'Actual Rolling {forecast_days}-Day Volatility', color='blue', linestyle='--')
        ax_garch.set_title(f'GARCH vs. Actual Volatility for {ticker}')
        ax_garch.set_xlabel('Date')
        ax_garch.set_ylabel('Annualized Volatility')
        ax_garch.legend()
        st.pyplot(fig_garch)

    elif selected_model == 'LSTM':
        st.write("The LSTM model is a type of recurrent neural network that can learn from sequences of data.")

        # LSTM Evaluation Metrics
        st.subheader("LSTM Evaluation Metrics")
        col_m1, col_m2 = st.columns(2)
        col_m1.metric("Mean Squared Error (MSE)", f"{lstm_mse:.6f}")
        col_m2.metric("Root Mean Squared Error (RMSE)", f"{lstm_rmse:.6f}")

        # Plot LSTM Predictions vs. Actual Volatility
        fig_lstm, ax_lstm = plt.subplots(figsize=(10, 5))
        ax_lstm.plot(df.index[30:], y_pred, label='LSTM Predicted Volatility', color='orange')
        ax_lstm.plot(df.index[30:], y_actual, label=f'Actual GARCH Volatility', color='green', linestyle='--')
        ax_lstm.set_title(f'LSTM Predictions vs. GARCH Volatility for {ticker}')
        ax_lstm.set_xlabel('Date')
        ax_lstm.set_ylabel('Annualized Volatility')
        ax_lstm.legend()
        st.pyplot(fig_lstm)

if __name__ == '__main__':
    main()